#include <EEPROM.h>
#include <Wire.h>
#include <RTClib.h>
#include <LiquidCrystal_I2C.h>
#include <NewPing.h>

#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define VRX_PIN A0  // Arduino pin connected to VRX pin
#define VRY_PIN A1  // Arduino pin connected to VRY pin
#define PIN_TRIG 12
#define PIN_ECHO 11
#define MAX_DISTANCE 200  // Constante para determinar la distancia m√°xima, que consideraremos correcta.

#define OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);

NewPing sonar(PIN_TRIG, PIN_ECHO, MAX_DISTANCE);

//direccion de EEPROM
int eeAddress = 0;

//Valores de jostick
uint8_t valorCoordenadaY;

const unsigned char huevo[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xf1, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0x01, 0xf3, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x3e, 0x00, 0xf3, 0xf8, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x3e, 0x7c, 0x73, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0x3e, 0x7e, 0x31, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x3e, 0x7f, 0x38, 0x7e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x3e, 0x7f, 0x1c, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x3e, 0x3f, 0x9f, 0x00, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc6, 0x7f, 0x1f, 0x87, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x8e, 0x7f, 0x9f, 0xc3, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0x7f, 0x8f, 0xf3, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x88, 0xff, 0xcf, 0xf3, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xe3, 0xc3, 0xe0, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xff, 0xf0, 0x07, 0x80, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xf8, 0x1e, 0x0e, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xf8, 0x07, 0xfc, 0x3f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xf0, 0x03, 0xfc, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xc3, 0xf1, 0xfc, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x07, 0xf8, 0xfc, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xfc, 0x7c, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xfe, 0x7c, 0x61, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xfe, 0x3e, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0x38, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char adulto[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfc, 0x3f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0x9f, 0x9f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x1f, 0xff, 0xef, 0x9f, 0xdf, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xe1, 0xff, 0xef, 0x9f, 0xdf, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xfc, 0x3f, 0xef, 0x9f, 0xdf, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x11, 0xff, 0xff, 0xff, 0x1f, 0xef, 0xff, 0xdf, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x7c, 0xff, 0xff, 0xfe, 0x4f, 0xef, 0xff, 0x9f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfc, 0xfe, 0x7f, 0xff, 0xfc, 0xe7, 0xcf, 0xff, 0x3f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfb, 0xfe, 0x7f, 0xff, 0xf8, 0xf3, 0xdf, 0xe0, 0x7f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0x7f, 0xff, 0xf3, 0xfb, 0xdf, 0xcf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0x00, 0x00, 0x87, 0xfc, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xdf, 0xfe, 0x7f, 0xff, 0x3f, 0xbf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0x9f, 0xfe, 0x7f, 0xff, 0x7f, 0xbf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xbf, 0xff, 0x3f, 0xfe, 0x3f, 0xbf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0x3f, 0xff, 0x3f, 0xfc, 0xbf, 0xbf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x3f, 0xf9, 0xbf, 0xbf, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0x7f, 0xff, 0x9f, 0x87, 0x7f, 0x3f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x00, 0x7e, 0xff, 0xff, 0xd0, 0x3c, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xff, 0xff, 0x87, 0xf3, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfe, 0x73, 0xfe, 0x00, 0x00, 0x3f, 0xcf, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xf9, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xe7, 0xff, 0xc0, 0xff, 0xff, 0x03, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0x00, 0x00, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf8, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x0f, 0x8b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xef, 0xde, 0xff, 0xff, 0xef, 0xbd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xed, 0xdd, 0xff, 0xff, 0xee, 0xdd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xed, 0xbd, 0xff, 0xff, 0xee, 0x5e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0xe0, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

const unsigned char infancia[] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xfc, 0x7f, 0xe0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xf9, 0x1f, 0x8f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xd7, 0xff, 0xfb, 0xdf, 0x7f, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x31, 0xff, 0xc3, 0xce, 0x7f, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0x0f, 0x9f, 0xee, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xe0, 0x07, 0x00, 0xe7, 0xf9, 0xef, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x0f, 0xf0, 0x79, 0xe7, 0xf9, 0xef, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xf8, 0xfe, 0x7f, 0xf9, 0xfd, 0xe7, 0xf9, 0xe7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfb, 0xfc, 0xff, 0xfd, 0xfc, 0xe7, 0xf9, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xf3, 0xfd, 0xff, 0xfc, 0xfe, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xe7, 0xfd, 0xff, 0xfe, 0x7e, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xfd, 0xf9, 0xf7, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xfd, 0xf9, 0xf7, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0x07, 0xf7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x9d, 0xbe, 0xff, 0xff, 0x7d, 0x80, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xbc, 0x3e, 0x00, 0x00, 0x7c, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x31, 0xbe, 0xf7, 0xff, 0x7d, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfc, 0xc7, 0xbe, 0xe7, 0xff, 0x7d, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xfc, 0x1f, 0x3e, 0x0f, 0xff, 0x7c, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xff, 0xfe, 0x7c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7c, 0xff, 0xfe, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7d, 0xff, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xfd, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// Paso 1: Creaci√≥n Estructura
struct SerVivo {
  // uint16_t transcursoDeVida;
  uint32_t ultimaFechaCrecimiento;
  uint8_t aporteComida;
  uint32_t ultimaFechaAporteComida;
  uint8_t aporteCarinyo;
  uint32_t ultimaFechaAporteCarinyo;
  uint8_t aporteLimpieza;
  uint32_t ultimaFechaAporteLimpieza;
  uint32_t ultimoGuardadoEEPROM;
  uint16_t faseSerVivo;
  uint8_t enfermo;
  uint32_t ultimaFechaEnfermedad;
  uint8_t genero;
};

// Paso 2: Asignaci√≥n de valores "por defecto"
SerVivo evolucionInicial = {
  0,   // ultimaFechaCrecimiento
  5,  // aporteComida
  0,   // ultimaFechaAporteComida
  5,  // aporteCarinyo
  0,   // ultimaFechaAporteCarinyo
  5,  // aporteLimpieza
  0,   // ultimaFechaAporteLimpieza
  0,   // ultimoGuardadoEEPROM
  0,   // faseSerVivo
  1,   // Enfermo
  0,   // ultimaFechaEnfermedad
  0    // Genero
};

//Objeto de estructura utilizada en el codigo
SerVivo evolucion;
const uint8_t faseFinalSerVivo = 3;

//Objetos de modulo reloj
RTC_DS3231 rtc;

//Objeto de modulo de LCD
LiquidCrystal_I2C lcd(0x27, 20, 4);

//constantes Reales
const uint32_t segundosGuardadoEEPROM = 21600;           // 6 horas
const uint32_t segundosEnfermado = 604800;               // 7 dias
const uint32_t segundosCrecimientoInicioHuevo = 1;       // 1s
const uint32_t segundosCrecimientoHuevoNinyo = 7200;     // 2 h
const uint32_t segundosCrecimientoNinyoAdulto = 172800;  // 2 dias

const uint32_t segundosComida = 18000;    // 5 horas
const uint32_t segundosLimpieza = 28800;  // 8 horas
const uint32_t segundosCarinyo = 14400;   // 4 horas 
const uint8_t distanciaAmorCm = 7;        // 7 cm 

//constantes Pruebas
/*const uint32_t segundosGuardadoEEPROM = 12600;       // 3.5h
const uint32_t segundosEnfermado = 10000;            // 10s
const uint32_t segundosCrecimientoInicioHuevo = 1;   // 1s
const uint32_t segundosCrecimientoHuevoNinyo = 5;   // 1h
const uint32_t segundosCrecimientoNinyoAdulto = 5;  // 2 h

const uint32_t segundosComida = 10800;    // 3h
const uint32_t segundosLimpieza = 10800;  // 3h
const uint32_t segundosCarinyo = 10800;   // 3h
const uint8_t distanciaAmorCm = 7;        // 3h*/

/*Pines*/
//Pulsadores
const uint8_t pulsadorComida = 7;
const uint8_t pulsadorCarinyo = 8;
const uint8_t pulsadorLimpieza = 9;
const uint8_t pulsadorEnfermo = 10;

/*Valores de enfermedad*/
const uint8_t numeroParaEnfermar = 13;
const uint8_t numeroMinimoParaEnfermar = 0;
const uint8_t numeroMaximoParaEnfermar = 30;

/*Valores de genero*/
const uint8_t numeroMinimoParaGenero = 1;
const uint8_t numeroMaximoParaGenero = 4;

uint8_t seleccionMenu = 1;

void setup() {
  Serial.begin(9600);

  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // here the 0x3c is the I2C address, check your i2c address if u have multiple devices.
  display.clearDisplay();
  delay(2000);

  rtc.begin();
  lcd.init();
  lcd.backlight();
  pinMode(pulsadorComida, INPUT_PULLUP);
  pinMode(pulsadorCarinyo, INPUT_PULLUP);
  pinMode(pulsadorLimpieza, INPUT_PULLUP);
  pinMode(pulsadorEnfermo, INPUT_PULLUP);
  randomSeed(analogRead(2));

  /*Borramos la EEPROM*/
  //borrarEEPROM();
  //ajusteHoraFecha();
  if (EEPROM.read(eeAddress) == 0) {
    DateTime momentoInicial = rtc.now();
    evolucionInicial.ultimaFechaCrecimiento = momentoInicial.unixtime();
    evolucionInicial.ultimaFechaAporteComida = momentoInicial.unixtime();
    evolucionInicial.ultimaFechaAporteCarinyo = momentoInicial.unixtime();
    evolucionInicial.ultimaFechaAporteLimpieza = momentoInicial.unixtime();
    evolucionInicial.ultimaFechaEnfermedad = momentoInicial.unixtime();
    /*Establecimiento de genero*/
    /*Valor 1 -> Femenino*/
    /*Valor 2 -> Masculino*/
    /*Valor 3 -> No binario*/
    evolucionInicial.genero = random(numeroMinimoParaGenero, numeroMaximoParaGenero);
    evolucion = evolucionInicial;
    guardarEEPROM(eeAddress, evolucion);
  } else {
    recuperarObjetoEEPROM(eeAddress);
    guardarEEPROM(eeAddress, evolucion);
  }
  //mostrar estadisticas
  mostrarPorLCDEvolucionBiologico();
  //mostrar imagen
  mostrarPorOLED(evolucion.faseSerVivo);
}

void loop() {
  DateTime momento = rtc.now();
  /*Lectura de ultrasonidos*/
  uint8_t distancia = sonar.ping_cm();
  /*Si la distancia es 0 siginifica que el objetivo esta muy lejos o muy cerca y la lectura no es correcta*/
  if (distancia < distanciaAmorCm && distancia > 0 && evolucion.faseSerVivo > 1 && evolucion.aporteCarinyo < 10) {
    evolucion.aporteCarinyo = evolucion.aporteCarinyo + 1;
    evolucion.ultimaFechaAporteCarinyo = momento.unixtime();
    delay(900);
  }

  /*Lectura de pulsadores*/
  if (digitalRead(pulsadorEnfermo) == LOW) {
    delay(100);
    while (digitalRead(pulsadorEnfermo) == LOW) {}
    if (evolucion.faseSerVivo > 1 && evolucion.enfermo == 1) {
      evolucion.enfermo = 0;
      evolucion.ultimaFechaEnfermedad = momento.unixtime();
    }
  }

  if (digitalRead(pulsadorComida) == LOW) {
    delay(100);
    while (digitalRead(pulsadorComida) == LOW) {}
    if (evolucion.faseSerVivo > 1 && evolucion.aporteComida < 10) {
      evolucion.aporteComida = evolucion.aporteComida + 1;
      evolucion.ultimaFechaAporteComida = momento.unixtime();
    }
  }

  if (digitalRead(pulsadorLimpieza) == LOW) {
    delay(100);
    while (digitalRead(pulsadorLimpieza) == LOW) {}
    if (evolucion.faseSerVivo > 1 && evolucion.aporteLimpieza < 10) {
      evolucion.aporteLimpieza = evolucion.aporteLimpieza + 1;
      evolucion.ultimaFechaAporteLimpieza = momento.unixtime();
    }
  }

  if (digitalRead(pulsadorCarinyo) == LOW) {
    delay(100);
    while (digitalRead(pulsadorCarinyo) == LOW) {}
    if (evolucion.faseSerVivo > 1 && evolucion.aporteCarinyo < 10) {
      evolucion.aporteCarinyo = evolucion.aporteCarinyo + 1;
      evolucion.ultimaFechaAporteCarinyo = momento.unixtime();
    }
  }

  //mostrar imagen
  mostrarPorOLED(evolucion.faseSerVivo);

  /*Verificamos si muere*/
  if ((evolucion.aporteCarinyo == 0 && evolucion.aporteComida == 0 && evolucion.aporteLimpieza == 0) || evolucion.enfermo == 2) {
    gameOver();
    mostrarPorLCDGameOver();
  } else {
    if (evolucion.faseSerVivo > 1) {
      /*Verificamos si se pone enfermo*/
      establecerEnfermedad(momento.unixtime(), evolucion.ultimaFechaEnfermedad);

      /*Verificamos el carino*/
      establecerAporteCarinyo(momento.unixtime(), evolucion.ultimaFechaAporteCarinyo);

      /*Verificamos la comida*/
      establecerAporteComida(momento.unixtime(), evolucion.ultimaFechaAporteComida);

      /*Verificamos la limpieza*/
      establecerAporteLimpieza(momento.unixtime(), evolucion.ultimaFechaAporteLimpieza);
    } else {
      /*Mientras este en fase huevo, se actualiza los momentos para que se actualice en el momento de la infancia*/
      /*De este modo comenzara a descontar el tiempo de ese momento*/
      /*en fase huevo actualizamos al ultimo momento las acciones que conlleven tiempo*/
      evolucion.ultimaFechaAporteComida = momento.unixtime();
      evolucion.ultimaFechaAporteCarinyo = momento.unixtime();
      evolucion.ultimaFechaAporteLimpieza = momento.unixtime();
      evolucion.ultimaFechaEnfermedad = momento.unixtime();
    }

    /*Verificamos si tienes que crecer*/
    /*Evitamos que entre a crecer si ya llego a su fase final*/
    crecimientoTranscursoDeVida(momento.unixtime(), evolucion.ultimaFechaCrecimiento);

    /*Guardamos cada X tiempo en EEPROM*/
    guardadoDiarioEEPROM(momento.unixtime(), evolucion.ultimoGuardadoEEPROM);

    /*Mostrar por pantalla*/
    /*Por defecto que salga el menu biologico*/
    
    int fase = evolucion.faseSerVivo;
    if (map(analogRead(VRY_PIN), 0, 1023, 0, 3) == 0) {
      delay(100);
      while (map(analogRead(VRY_PIN), 0, 1023, 0, 3) == 0) {}
      // En caso que sea huevo siempre mostrare la seleccion 1 que es a nivel biologico
      if (fase <= 1) {
        seleccionMenu == 1;
      } else {
        seleccionMenu = 0;
      }
      lcd.clear();
    }

    if (map(analogRead(VRY_PIN), 0, 1023, 0, 3) == 2) {
      delay(100);
      while (map(analogRead(VRY_PIN), 0, 1023, 0, 3) == 2) {}
      seleccionMenu = 1;
      lcd.clear();
    }

    if (seleccionMenu == 1) {
      mostrarPorLCDEvolucionBiologico();
    } else {
      mostrarPorLCDEvolucionEstadisticas();
    }
  }
}

/*
** Mostrar GAME OVER
*/
void mostrarPorLCDGameOver() {
  lcd.clear();
  lcd.setCursor(5, 1);
  lcd.print("GAME  OVER");
  lcd.setCursor(6, 3);
  lcd.print("Reinicia");
}

/*
** Mostras LCD la evolucion Estadisticas
*** Comida
*** Amor
*** Limpieza
*/
void mostrarPorLCDEvolucionEstadisticas() {
  lcd.setCursor(0, 0);
  lcd.print("----Estadisticas----");
  lcd.setCursor(0, 1);
  lcd.print("Comida : ");
  lcd.print((evolucion.aporteComida));
  if (evolucion.aporteComida < 10) {
    lcd.print("         ");
  }
  lcd.setCursor(0, 2);
  lcd.print("Amor : ");
  lcd.print((evolucion.aporteCarinyo));
  if (evolucion.aporteCarinyo < 10) {
    lcd.print("         ");
  }
  lcd.setCursor(0, 3);
  lcd.print("Limpieza : ");
  lcd.print((evolucion.aporteLimpieza));
  if (evolucion.aporteLimpieza < 10) {
    lcd.print("         ");
  }
}

/*
** Mostras LCD la evolucion Biologicas
*** Fase de evolucion
*** Genero
*** Si esta enfermo o no
*/
void mostrarPorLCDEvolucionBiologico() {
  String textoFase = recuperarTextoFase(evolucion.faseSerVivo);
  String textoGenero = recuperarTextoGenero(evolucion.genero);
  String textoEnfermedad = recuperarTextoEnfermedad(evolucion.enfermo, evolucion.faseSerVivo);
  lcd.setCursor(0, 0);
  lcd.print("Fase : ");
  lcd.print(textoFase);
  lcd.setCursor(0, 1);
  lcd.print("Genero : ");
  lcd.print(textoGenero);
  lcd.setCursor(0, 3);
  lcd.print(textoEnfermedad);
}

/*
** Mostramos texto segun la fase
*/
String recuperarTextoFase(uint16_t faseSerVivo) {
  String fase;
  switch (faseSerVivo) {
    case 1:
      fase = "Huevo    ";
      break;
    case 2:
      fase = "Infancia ";
      break;
    case 3:
      fase = "Adulto   ";
      break;
    default:
      fase = "Huevo    ";
  }
  return fase;
}

/*
** Mostramos texto segun el genero
*/
String recuperarTextoGenero(uint8_t generoSerVivo) {
  String genero;
  switch (generoSerVivo) {
    case 1:
      genero = "Femenino";
      break;
    case 2:
      genero = "Masculino";
      break;
    case 3:
      genero = "No binario";
      break;
  }
  return genero;
}

/*
** Mostramos texto segun el genero
*/
String recuperarTextoEnfermedad(uint8_t enfermoSerVivo, uint16_t faseSerVivo) {
  String enfermo;
  if (faseSerVivo <= 1) {
    enfermo = "";
  } else {
    switch (enfermoSerVivo) {
      case 0:
        enfermo = "Estoy genial        ";
        break;
      case 1:
        enfermo = "Me encuentro mal";
        break;
      case 2:
        enfermo = "Estoy agonizando";
        break;
    }
  }
  return enfermo;
}

/**
** Funcion de Enfermedad
** Si el contador llega a 2 de enfermedad, se genera un GAME OVER
*/
void establecerEnfermedad(uint32_t segundosFechaActual, uint32_t segundosUltimaEnfermedad) {
  uint32_t diferencia = segundosFechaActual - segundosUltimaEnfermedad;
  if (diferencia >= segundosEnfermado) {
    long numeroRandomEnfermo;
    numeroRandomEnfermo = random(numeroMinimoParaEnfermar, numeroMaximoParaEnfermar);
    if (numeroParaEnfermar == numeroRandomEnfermo) {
      if (evolucion.enfermo == 1) {
        evolucion.enfermo = evolucion.enfermo + 1;
      } else {
        evolucion.enfermo = 1;
      }
    }
    evolucion.ultimaFechaEnfermedad = segundosFechaActual;
  }
}

/**
** Funcion de limpieza
*/
void establecerAporteLimpieza(uint32_t segundosFechaActual, uint32_t segundosUltimaLimpieza) {
  uint32_t diferencia = segundosFechaActual - segundosUltimaLimpieza;
  if (diferencia >= segundosLimpieza && evolucion.aporteLimpieza > 0) {
    evolucion.aporteLimpieza = evolucion.aporteLimpieza - 1;
    evolucion.ultimaFechaAporteLimpieza = segundosFechaActual;
  }
}

/**
** Funcion de carinyo
*/
void establecerAporteCarinyo(uint32_t segundosFechaActual, uint32_t segundosUltimaCarinyo) {
  uint32_t diferencia = segundosFechaActual - segundosUltimaCarinyo;
  if (diferencia >= segundosCarinyo && evolucion.aporteCarinyo > 0) {
    evolucion.aporteCarinyo = evolucion.aporteCarinyo - 1;
    evolucion.ultimaFechaAporteCarinyo = segundosFechaActual;
  }
}

/**
** Funcion de comida
*/
void establecerAporteComida(uint32_t segundosFechaActual, uint32_t segundosUltimaComida) {
  uint32_t diferencia = segundosFechaActual - segundosUltimaComida;
  if (diferencia >= segundosComida && evolucion.aporteComida > 0) {
    evolucion.aporteComida = evolucion.aporteComida - 1;
    evolucion.ultimaFechaAporteComida = segundosFechaActual;
  }
}

/**
** Funcion de segundos segun la fase del ser vivo
** Saber la fase en la que estoy del ser vivo
*/
uint32_t establecerDiferenciaSegundoSerVivo(uint16_t faseSerVivo) {
  uint32_t segundos = 0;
  switch (faseSerVivo) {
    case 0:
      segundos = segundosCrecimientoInicioHuevo;
      break;
    case 1:
      segundos = segundosCrecimientoHuevoNinyo;
      break;
    case 2:
      segundos = segundosCrecimientoNinyoAdulto;
      break;
  }

  return segundos;
}

/**
** Funcion de crecimiento
** Si la diferencia es mayor o igual a los segundos establecidos -> Crece
** Si la diferencia es menor a los segundos establecidos -> No Crece
** Guardamos en EEPROM cuando crezca 
*********************
** FASES del SER VIVO
*** Fase = 0 -> Inicio
*** Fase = 1 -> Huevo
*** Fase = 2 -> Ninyo
*** Fase = 3 -> Adulto
*********************
*/
void crecimientoTranscursoDeVida(uint32_t segundosFechaActual, uint32_t segundosFechaNacimiento) {
  uint32_t diferenciaDia = segundosFechaActual - segundosFechaNacimiento;
  if (diferenciaDia >= establecerDiferenciaSegundoSerVivo(evolucion.faseSerVivo) && evolucion.faseSerVivo < faseFinalSerVivo) {  
    evolucion.faseSerVivo = evolucion.faseSerVivo + 1;
    evolucion.ultimaFechaCrecimiento = segundosFechaActual;
    guardarEEPROM(eeAddress, evolucion);
  }
}

/** 
** Funcion de guardado de EEPROM
** Si la diferencia es mayor o igual a los segundos establecidos -> Guarda
** Si la diferencia es menor a los segundos establecidos -> No Guarda
*/
void guardadoDiarioEEPROM(uint32_t segundosFechaActual, uint32_t segundosultimoGuardado) {
  uint32_t diferencia = segundosFechaActual - segundosultimoGuardado;
  if (diferencia >= segundosGuardadoEEPROM) {
    evolucion.ultimoGuardadoEEPROM = segundosFechaActual;
    guardarEEPROM(eeAddress, evolucion);
  }
}

/**
** Fin de la vida - Vaciamos de la EEPROM
*/
void gameOver() {
  borrarEEPROM();
}

/**
** Vaciamos de la EEPROM
*/
void borrarEEPROM() {
  for (int i = 0; i < EEPROM.length(); i++) {
    EEPROM.write(i, 0);
  }
}

/**
** Guardamos en EEPROM
*/
void guardarEEPROM(int eeAddress, SerVivo evolucion) {
  EEPROM.put(eeAddress, evolucion);
}

/**
** Guardamos en EEPROM
*/
void recuperarObjetoEEPROM(int eeAddress) {
  EEPROM.get(eeAddress, evolucion);
}

/**
** Ajuste de fecha y hora
** Solo se realiza una unica vez o alcambiar la pila del modulo RTC
*/
void ajusteHoraFecha() {
  rtc.adjust(DateTime(2024, 8, 16, 9, 1, 0));
}

/**
** mostrar imagen por OLED
*/
void mostrarPorOLED(uint16_t faseSerVivo) {
  display.clearDisplay();
  switch (faseSerVivo) {
    case 0:
      display.drawBitmap(0, 0, huevo, 128, 64, WHITE);
      break;
    case 1:
      display.drawBitmap(0, 0, huevo, 128, 64, WHITE);
      break;
    case 2:
      display.drawBitmap(0, 0, infancia, 128, 64, WHITE);
      break;
    case 3:
      display.drawBitmap(0, 0, adulto, 128, 64, WHITE);
      break;
  }
  display.display();
}